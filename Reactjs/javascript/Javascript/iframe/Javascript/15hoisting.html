<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h2>What is Hoisting</h2>
    <b>ANS -:</b><i> In javascript, hosting refers to the built-in-beheviour of the lang
      through which declration of functiuon, Variables,and classes are moved to
      the top of thire scope - all before code execution.In turn, this allows us
      yo use functhion,m variables, and classes before threy are ddclered.</i
    >

    <ul>
        <li>In this post, we'll expolore a few Examples of hoosting, as well as look
            at the impect that hosting has on the code we write.</li>
    </ul>
      
    

    <h2>Declaration</h2>
    <p>
      Before we begin,let's make sure we're on the same page regarding
      Declaration. In javascript, Declaration incluide using:
    </p>
    <div>
      <ul>
        <li>function to be declare a function (incluide generators)</li>
        <li>
          async function to be declare an syne function (incluide generators)
        </li>
        <li>class to declare class</li>
        <li>var to declare variable</li>
        <li>let to declare block-scoped variable</li>
        <li>const to declare a block-scoped,non-reassignble variable</li>
      </ul>
    </div>
    <div>
      <details>
        <summary>
          Example
        </summary>
        <pre>
          // Declaration a function 
          function myfunction() {
            //...
          } 
          
          // Declaration a variable 
          let a = "a";
          
          // Declaration a class 
          class Myclass {
              0  //...
            }
            </pre>
          </details>
            <p>
              In the above snippet, we are simply making three declarations: a
              function, a variable, and a class. Now, what does it mean to hoist these
              declarations?
            </p>
          </div>
          
          <h2>Functhion hosting.</h2>
          <p>
            Under the hood, function declarations are put into memory at compile time.
            As such, this makes it possible to, on execution, call a declared function
            before it is defined.
    </p>

    <details>
      <summary>
        Example
      </summary>
      <pre>
        
        console.log(greeting()); // "Hello there!"
        
        
        function greeting() 
        return "Hello there!";
        
        
      </pre>
    </details> 
    <p>In the above snippet, we are able to log the return value of invoking greeting() before that function is even defined. This is all due to function hoisting – a built-in behavior of JavaScript that hoists a function’s declaration and its value to the top of their scope.</p>

    <ul>
      <li>
            <b>Note that this differs from invoking a function that is never declared:</b>
        </li>
    </ul>
    <pre>
        console.log(greeting()); // ReferenceError: greeting is not defined
        
    </pre>
    <p>Since the function is never defined anywhere, the JavaScript interpreter evaluates the expression as a ReferenceError.</p>
    <p>Now that we’ve seen how JavaScript hoists functions, let’s take a look at how variables are hoisted.</p>

    
    <h2>Variable hoisting with var.</h2>
    <p>Unlike function hoisting, variable hoisting shows slightly different behavior. When a variable is declared with the var keyword, the JavaScript interpreter still hoists its declaration. However, it differs from how functions are hoisted in that the value of the variable (if it has one) is not included.</p>

    <details>

      <summary>
        Example
      </summary>
      <pre>
        
        console.log(a); // undefined
        
        var a = "a";
        
        console.log(a); // "a"
      </pre>
    </details>
    <p>When the variable a is hoisted, the JavaScript engine still moves it to the top of its scope – but it initializes the variable with a value of undefined. As such, until a is actually declared on the next line, its actual value won’t be assigned. Then, after declaration, we can finally log its value to the console: “a“.</p>
    <p>Now, what about variables declared with the let and const keywords? As it turns out, there are some slightly different behaviors declaring block-scoped variables as well.</p>

    
    <h2>Variable hoisting with let and const.</h2>
    <p>Similar to declaring a variable with var, the declaring a variable with let or const still sees the variable declaration hoisted to the top of its scope. However, rather than initializing that variable with a value (i.e., undefined, as shown above), the JavaScript engine forgoes that step entirely. As such, by not being initialized, the JavaScript interpreter will throw an error if we try to access the variable:</p>

    <details>
      <summary>
        Example
      </summary>
      <pre>
        console.log(a); // ReferenceError: Cannot access 'a' before initialization
        
        console.log(b); // ReferenceError: b is not defined
        
        let a = "a";
        
        console.log(a); // "a"
      </pre>
    </details>

    <p>The reason why we see these errors, even though variable a is properly hoisted, is due to the variable being in the temporal dead zone (TDZ). That is, while the variable is in scope, we cannot access or use the variable at all before it is explicitly declared. This same behavior also applies when declaring a class with the class keyword:</p>

    <details>
      <summary>
        Example
      </summary>
      <pre> 
        let instance = new MyClass(); // Cannot access 'MyClass' before initialization
        
        class MyClass {
          // ...
        }
      </pre>
    </details>
    <p>Certain developers in the community may argue that declarations with let, const, or class are non-hoisting in the most strict sense.</p>
    <p>Now that we’ve seen how different declarations can be hoisted, what significance does this have in code?</p>

    <h2>To hoist or not to hoist?</h2>

    <p>Hoisting is not explicitly defined in the ECMAscript specification, which describes the standards of JavaScript as a language. For the most part, you should consider hoisting as more of a default behavior of JavaScript rather than a feature. That is, rather than leveraging hoisting as a practical tool or design pattern in the scripts and applications you write, you should just be mindful of its characteristics as you continue to work with JavaScript.</p>

    <p>In certain code bases, for example, you might come across functions being used in business logic at the top of the script, while its declarations are left at the bottom of the script (something that AirBnb’s JavaScript Style Guide advises against). Though less common and probably only partially useful, know that this is all possible due to hoisting</p>

    <h2>Learn more about hoisting.</h2>

    <p>For more information about hoisting, declarations, and scope in JavaScript, check out these resources:</p>
    
    <div>
      <ul>
        <li>Statements and declarations on MDN</li>
        <li>Hoisting on MDN</li>
        <li>ES6 – JavaScript Improved</li>
        <li>Object-Oriented JavaScript</li>
      </ul>

      <p>
        Or explore the Intermediate JavaScript Nanodegree program to master the most popular programming language in the world
      </p>
    </div>
    



  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>

    <h2>Data types</h2>
    <h3>1.Primetive Datatype</h3>
    <p>The predefined data types provided by JavaScript language are known as primitive data types. Primitive data types are also known as in-built data types.</p>
    <div>
      <ul>
        <li>Number: JavaScript numbers are always stored in double-precision 64-bit binary format IEEE 754. Unlike other programming languages, you don’t need int, float, etc to declare different numeric values.</li>
        <li>String: JavaScript Strings are similar to sentences. They are made up of a list of characters, which is essentially just an “array of characters, like “Hello GeeksforGeeks” etc.</li>
        <li>Boolean: Represent a logical entity and can have two values: true or false</li>
        <li>Null: This type has only one value that is null.</li>
        <li>Undefined: A variable that has not been assigned a value is undefined.</li>
        <li>Symbol: Symbols return unique identifiers that can be used to add unique property keys to an object that won’t collide with keys of any other code that might add to the object</li>
        <li>Symbol: Symbols return unique identifiers that can be used to add unique property keys to an object that won’t collide with keys of any other code that might add to the object.</li>
      </ul>
    </div>
    <h3>Non-Primitive Datatype</h3>
    <p>The data types that are derived from primitive data types of the JavaScript language are known as non-primitive data types. It is also known as derived data types or reference data types.</p>
    <div>
      <ul>
        <li>Object: It is the most important data type and forms the building blocks for modern JavaScript. We will learn about these data types in detail in further articles.</li>
      </ul>
    </div>

    <h2>JavaScript Primitive Data Types Examples:</h2>
    <h4>Number</h4>
    <p>The number type in JavaScript contains both integer and floating-point numbers. Besides these numbers, we also have some ‘special-numbers’ in javascript that are: ‘Infinity’, ‘-Infinity’, and ‘NaN’. Infinity basically represents the mathematical ‘?’. The ‘NaN’ denotes a computational error.</p>
    <pre>
      let num = 2; // Integer 
      let num2 = 1.3; // Floating point number
      let num3 = Infinity; // Infinity
      let num4 = 'something here too'/2; // NaN
    </pre>

    <h4>string</h4>
    <p>A String in javascript is basically a series of characters that are surrounded by quotes. There are three types of quotes in Javascript, which are:</p>
    <pre>
      let str = "Hello There";
      let str2 = 'Single quotes works fine';
      let phrase = `can embed ${str}`;
    </pre>
    <h4>Boolean</h4>
    <p>The boolean type has only two values: true and false. This data type is used to store yes/no values: true means “yes, correct”, and false means “no, incorrect”.</p>
    <pre>
      let isCoding = true; // yes
      let isOld = false;      // no
    </pre>

    <h4>Null</h4>
    <p>The special null value does not belong to any of the default data types. It forms a separate type of its own which contains only the null value:</p>
    <pre>
      let age = null;
    </pre>
    <p>The ‘null’ data type basically defines a special value that represents ‘nothing’, ’empty’, or ‘value unknown’. Undefined Just like null, Undefined makes its own type. The meaning of undefined is ‘value is not assigned’.</p>
    <pre>
      let x;
      console.log(x);  // undefined
    </pre>



  
    <h2>Dynamic and weak typing</h2>
    <p>JavaScript is a dynamic language with dynamic types. Variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned (and re-assigned) values of all types:</p> 
    
    <pre>
      let foo = 42; // foo is now a number
      foo = "bar"; // foo is now a string
      foo = true; // foo is now a boolean
    </pre>

    <p>JavaScript is also a weekly  typed lang, which means allows implicit type conversion when an operation involves mismatched type , instead of throwing type errors.</p>

    <pre>
      const foo = 42; // foo is a number
      const result = foo + "1"; // JavaScript coerces foo to a string, so it can be concatenated with the other operand
      console.log(result); // 421

    </pre>

    
    <pre>
      <b>
        Type	typeof return value	Object wrapper
      </b>
      Null	   "object"       	N/A
      Undefined	   "undefined"    	N/A
      Boolean      "boolean"      	Boolean
      Number	   "number"       	Number
      BigInt	   "bigint"	        BigInt
      String	   "string"	        String
      Symbol	   "symbol"        	Symbol
      
    </pre>
    

    <h3>
      <a href="#other coercions">other coercions</a>
    </h3>
    <p>
      All data types, except Null, Undefined, and Symbol, have their respective coercion process. See
      <a href="#string">string</a>
      ,
      <a href="#coercions">coercions</a>
      ,
      <a href="#boolean coercions">boolean coercions</a>
      , and
      <a href="#object coercions">object coercions</a>
      for more details.

    </p>
    <p>As you may have noticed, there are three distinct paths through which objects may be converted to primitives:</p>
      <div>
        <ul>
          <li>Primitive coercion: [@@toPrimitive]("default") → valueOf() → toString()</li>
          <li>Numeric coercion, number coercion, BigInt coercion: [@@toPrimitive]("number") → valueOf() → toString()</li>
          <li>String coercion: [@@toPrimitive]("string") → toString() → valueOf()</li>
        </ul>

        <p>In all cases, [@@toPrimitive](), if present, must be callable and return a primitive, while valueOf or toString will be ignored if they are not callable or return an object. At the end of the process, if successful, the result is guaranteed to be a primitive. The resulting primitive is then subject to further coercions depending on the context</p>

      </div>



    

  </body>
</html>
